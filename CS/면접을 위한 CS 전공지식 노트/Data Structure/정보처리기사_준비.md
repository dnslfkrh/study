# 배열 (Array)
- 동일한 자료형의 데이터틀이 같은 크기로 나열되어 순서를 가지는 집합
- 정적인 자료 구조로 기억장소의 추가가 어려움
- 데이터 삭제 시 데이터가 저장되어 있던 기억장소는 빈 공간으로 남아 메모리 낭비 발생
- 첨자(지수 표시하는 방법)를 이용한 데이터 접근
- 반복적인 데이터 처리에 적합
- 데이터마다 동일한 이름의 변수 사용으로 처리 간편
- 첨자 개수에 따라 n차원 배열이라고 함

```c
int arr[5] = { 10, 20, 30, 40, 50 }
// int: 모든 요소가 동일한 자료형
// arr[5]: 각 요소의 크기가 동일 (int = 4byte)
// { 10, 20, 30, 40, 50}: 순서를 가지며 저장
// 배열의 크기는 컴파일 시점에서 고정되어 변경되지 않음: 정적 자료 구조


int arr[5] = {10, 20, 30, 40, 50};
int size = 5;

// index 2의 값(30) 삭제
for (int i = 2; i < size - 1; i++) {
    arr[i] = arr[i + 1];
}
size--;
// 논리적으로는 삭제되어도, 빈 공간이 그대로 남아 있음


printf("%d\n", arr[2]); // 30
// 내부 동작
*(arr + 2)
// arr: 시작 주소
// 첨자 2: offset(거리, 상쇄하다)


for (int i = 0; i < 5; i++) {
    printf("%d ", arr[i]);
}
// 반복적인 데이터 처리에 적합
// 일괄 처리, 통계, 합계에 적합


// 배열이 없다면
int a1 = 10, a2 = 20, a3 = 30, a4 = 40, a5 = 50;
// 배열 사용
int arr[5] = {10, 20, 30, 40, 50};


// 첨자 개수에 따른 n차원 배열
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
// 2차원 배열로, 실제 구조는 1 2 3 4 5 6

matrix[1][2]; // 6
// 0부터 1까지 -> [1]
// 0부터 2까지 -> [2]
// matrix[1][2] -> 두번째 묶음에서 세번째
// 첫번째 묶음: {1, 2, 3}
// 두번째 묶음: {4, 5, 6}
```
